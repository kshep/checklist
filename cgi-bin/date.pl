#!/usr/local/bin/perl4.036
#======================================================================
#  date manipulation routines
#----------------------------------------------------------------------
#   a1   03/04/96   Original Version (alpha 1)
#----------------------------------------------------------------------

require "throw.pl";

#======================================================================
# 
#  datecheck - this subroutine takes a string containing a date as
#              input and returns a string containing a date as
#              output.
#
#  Arguments:  string containing date to check
#
#  Returns:    string containing date in RFC 1123 format
#
#----------------------------------------------------------------------
#
#  Notes:
#
#  The input date can be in any of the three formats recognized as
#  valid in the draft of HTTP/1.1 of January 19,1996 (attached) and
#  is returned in the prefered format of RFC 1123.
#
#  It also recognizes a variation on the asctime format that includes
#  the timezone between seconds and the year.
# 
# [ see original document for footnotes - kcs ] 
# 
# HTTP Working Group                                R. Fielding, UC Irvine
# INTERNET-DRAFT                                       H. Frystyk, MIT/LCS
# <draft-ietf-http-v11-spec-01.txt>                T. Berners-Lee, MIT/LCS
# Expires in six months                                   January 19, 1996
# 
#                Hypertext Transfer Protocol -- HTTP/1.1
# 
# 3.3.1 Full Date
# 
#    HTTP applications have historically allowed three different formats 
#    for the representation of date/time stamps:
# 
#        Sun, 06 Nov 1994 08:49:37 GMT    ; RFC 822, updated by RFC 1123
#        Sunday, 06-Nov-94 08:49:37 GMT   ; RFC 850, obsoleted by RFC 1036

#        Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
# 
#    The first format is preferred as an Internet standard and 
#    represents a fixed-length subset of that defined by RFC 1123 [8] 
#    (an update to RFC 822 [9]). The second format is in common use, but 
#    is based on the obsolete RFC 850 [12] date format and lacks a 
#    four-digit year. HTTP/1.1 clients and servers that parse the date 
#    value must accept all three formats, though they must only generate 
#    the RFC 1123 format for representing date/time stamps in HTTP 
#    message fields.
# 
#        Note: Recipients of date values are encouraged to be robust 
#        in accepting date values that may have been generated by 
#        non-HTTP applications, as is sometimes the case when 
#        retrieving or posting messages via proxies/gateways to SMTP 
#        or NNTP.
# 
#    All HTTP date/time stamps must be represented in Universal Time 
#    (UT), also known as Greenwich Mean Time (GMT), without exception. 
#    This is indicated in the first two formats by the inclusion of 
#    "GMT" as the three-letter abbreviation for time zone, and should be 
#    assumed when reading the asctime format.
# 
#        HTTP-date      = rfc1123-date | rfc850-date | asctime-date
# 
#        rfc1123-date   = wkday "," SP date1 SP time SP "GMT"
#        rfc850-date    = weekday "," SP date2 SP time SP "GMT"
#        asctime-date   = wkday SP date3 SP time SP 4DIGIT
# 
#        date1          = 2DIGIT SP month SP 4DIGIT
#                         ; day month year (e.g., 02 Jun 1982)
#        date2          = 2DIGIT "-" month "-" 2DIGIT
#                         ; day-month-year (e.g., 02-Jun-82)
#        date3          = month SP ( 2DIGIT | ( SP 1DIGIT ))
#                         ; month day (e.g., Jun  2)
# 
#        time           = 2DIGIT ":" 2DIGIT ":" 2DIGIT
#                         ; 00:00:00 - 23:59:59
# 
#        wkday          = "Mon" | "Tue" | "Wed"
#                       | "Thu" | "Fri" | "Sat" | "Sun"
# 
#        weekday        = "Monday" | "Tuesday" | "Wednesday"
#                       | "Thursday" | "Friday" | "Saturday" | "Sunday"
# 
#        month          = "Jan" | "Feb" | "Mar" | "Apr"
#                       | "May" | "Jun" | "Jul" | "Aug"
#                       | "Sep" | "Oct" | "Nov" | "Dec"
# 
#        Note: HTTP requirements for the date/time stamp format apply 
#        only to their usage within the protocol stream. Clients and 
#        servers are not required to use these formats for user 
#        presentation, request logging, etc.
# 
#----------------------------------------------------------------------

sub datecheck {

   ###  sub datecheck ( $in )

   local($in) = @_;
   local($nulldate,$zerodate);
   local($day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone);

   #
   #  It's convenient to have a null date which we
   #  consider to be "now"
   #
   $nulldate = ",  0  2000 00:00:00 GMT";
   $zerodate = "Sun,  1 Jan 1901 01:00:00 GMT";

   if ( $in eq "0" )       { return($zerodate) };
   if ( $in eq "" )        { return($nulldate) };
   if ( $in eq $nulldate ) { return($nulldate) };

   #
   #  Break date into appropriate parts
   #
   if ( $in =~ /,/ ){
      ($day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone) = 
      ($in =~ /^(\w+), +(\d+)[- ](\w+)[- ](\d+) +(\d+):(\d+):(\d+) +(\w+)$/);
   } else {
      $zone = "GMT";
      ($day,$month,$dayofmonth,$hour,$min,$sec,$year) = 
      ($in =~ /^(\w+) +(\w+) +(\d+) +(\d+):(\d+):(\d+) +(\w+)/);
      if ( $year =~ /T/ ){   # variation on asctime
         ($day,$month,$dayofmonth,$hour,$min,$sec,$zone,$year) = 
         ($in =~ /^(\w+) +(\w+) +(\d+) +(\d+):(\d+):(\d+) +(\w+) +(\w+)/);
      }
   }

   #
   #  Adjust the year based on the assumption that we're only
   #  working with dates between 1951 and 2050.
   #
   if ( ($year > 50) && ($year < 99) ) {
      $year = 1900 + $year;
   } else {
      $year = 2000 + $year if ( $year <= 50 );
   }

   #
   #  Build fields for RFC 1123 
   #
   $day  =~ s/^(...).*/$1/;

   #
   #  Return date
   #
   sprintf("%s, %2d %s %4s %02d:%02d:%02d %s",
            $day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone);

}

#======================================================================
#
#  datecomp  - compares two dates in RFC 1123 format.
#
#----------------------------------------------------------------------
#  Arguments:  string containing first date
#              string containing second date
#----------------------------------------------------------------------
#  Returns:    -1 if $1 < $2
#               0 if $1 = $2
#               1 if $1 > $2
#----------------------------------------------------------------------

sub datecomp {

   ###  sub datecomp ( $in1, $in2 )

   local($in1,$in2) = @_;
   local($nulldate) = &datecheck("");

   local(%mo) = (
      "Jan", 1, "Feb", 2, "Mar", 3, "Apr",  4, "May",  5, "Jun",  6,
      "Jul", 7, "Aug", 8, "Sep", 9, "Oct", 10, "Nov", 11, "Dec", 12
   );

   #
   #  Handle special cases first
   #
   return ( 0) if $in1 eq $in2;
   #
   #  We consider nulldate to be "now" so do appropriate
   #  comparisons
   # 
   return ( 1) if ( ($in1 eq $nulldate) && ($in2 ne $nulldate) );
   return ( 0) if ( ($in1 eq $nulldate) && ($in2 eq $nulldate) );
   return (-1) if ( ($in1 ne $nulldate) && ($in2 eq $nulldate) );

   $in1 = &datetotz($in1,"GMT");
   $in2 = &datetotz($in2,"GMT");

   ($day1,$dayofmonth1,$month1,$year1,$hour1,$min1,$sec1,$zone1) = 
   ($in1 =~ /^(\w+), +(\d+) +(\w+) +(\d+) +(\d+):(\d+):(\d+) +(\w+)$/);

   ($day2,$dayofmonth2,$month2,$year2,$hour2,$min2,$sec2,$zone2) = 
   ($in2 =~ /^(\w+), +(\d+) +(\w+) +(\d+) +(\d+):(\d+):(\d+) +(\w+)$/);

   return (-1) if $year1 < $year2;
   return ( 1) if $year1 > $year2;

   return (-1) if $mo{$month1} < $mo{$month2};
   return ( 1) if $mo{$month1} > $mo{$month2};

   return (-1) if $dayofmonth1 < $dayofmonth2;
   return ( 1) if $dayofmonth1 > $dayofmonth2;

   return (-1) if $hour1 < $hour2;
   return ( 1) if $hour1 > $hour2;

   return (-1) if $min1 < $min2;
   return ( 1) if $min1 > $min2;

   return (-1) if $sec1 < $sec2;
   return ( 1) if $sec1 > $sec2;

   &throw("Strange date compare",$in1,$in2);

}
#======================================================================
#
#  datenow - generate a string containing the current date in RFC 1123
#            format;
#
#----------------------------------------------------------------------
#  Arguments:  none
#----------------------------------------------------------------------
#  Returns:    string containing date
#----------------------------------------------------------------------

sub datenow {

   ###  sub datenow ()

   local(@dofw) = ( "Sun","Mon","Tue","Wed","Thu","Fri","Sat" );
   local(@mofy) = ( "Jan","Feb","Mar","Apr","May","Jun",
                    "Jul","Aug","Sep","Oct","Nov","Dec" );

   local($sec,$min,$hour,$dayofmonth,$mon,$year,$wday,$yday,$isdst) 
      = gmtime(time);

   #
   #  Adjust the year based on the assumption that we're only
   #  working with dates between 1951 and 2050.
   #
   if ( ($year > 50) && ($year < 99) ) {
      $year = 1900 + $year;
   } else {
      $year = 2000 + $year if ( $year <= 50 );
   }

   $day   = $dofw[$wday];
   $month = $mofy[$mon];
   $zone  = "GMT";

   sprintf("%s, %2d %s %s %02d:%02d:%02d %s",
            $day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone);

}

#======================================================================
#
#  dateshort - converts date in RFC 1123 format to mm/dd/yy format.
#
#----------------------------------------------------------------------
#  Arguments:  string containing RFC 1123 date
#----------------------------------------------------------------------
#  Returns:    string containing short date
#----------------------------------------------------------------------

sub dateshort {

   ###  sub dateshort ( $in )

   local($in) = @_;

   local(%mo) = (
      "Jan", 1, "Feb", 2, "Mar", 3, "Apr",  4, "May",  5, "Jun",  6,
      "Jul", 7, "Aug", 8, "Sep", 9, "Oct", 10, "Nov", 11, "Dec", 12
   );

   local($day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone) = 
      ($in =~ /^(\w+), +(\d+) +(\w+) +(\d+) +(\d+):(\d+):(\d+) +(\w+)$/);

   local($rmonth)   = $mo{$month};
   local($rday)     = $dayofmonth;
   local($ryear)  = ( $year =~ /\d\d(\d\d)/);

   return( "$rmonth/$rday/$ryear");

}
#======================================================================
#
#  datetotz - converts GMT date in RFC 1123 format to the given TZ
#
#----------------------------------------------------------------------
#  Arguments:  string containing RFC 1123 date
#----------------------------------------------------------------------
#  Returns:    string containing short date
#----------------------------------------------------------------------

sub datetotz {

   ###  sub dateshort ( $gmtdate, $tz )

   local($gmtdate,$tz) = @_;
   local($returnval);

   #
   #  Set up arrays for hours before GMT; month and day numbers
   #
   local(%offset) = ( 
      "GMT",0,
      "EST",5,"CST",6,"MST",7,"PST",8,
      "EDT",4,"CDT",5,"MDT",6,"PDT",7
   );
   local(%monum) = (
      "Jan", 0, "Feb", 1, "Mar", 2, "Apr",  3, "May",  4, "Jun",  5,
      "Jul", 6, "Aug", 7, "Sep", 8, "Oct",  9, "Nov", 10, "Dec", 11
   );
   local(%daynum) = (
      "Sun",0,"Mon",1,"Tue",2,"Wed",3,"Thu",4,"Fri",5,"Sat",6
   );

   local(@dofw) =     ( "Sun","Mon","Tue","Wed","Thu","Fri","Sat" );
   local(@mofy) =     ( "Jan","Feb","Mar","Apr","May","Jun",
                        "Jul","Aug","Sep","Oct","Nov","Dec" );
   local(@daysinmo) = (  31  , 28  , 31  , 30  , 31  , 30  ,
                         31  , 31  , 30  , 31  , 30  , 31   );

   #
   #  Split date
   #
   local($day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone) = 
      ($gmtdate =~ /^(\w+), +(\d+) +(\w+) +(\d+) +(\d+):(\d+):(\d+) +(\w+)$/);

   #
   #  If TZ isn't recognized or if no conversion required, keep it
   #
   return ($gmtdate) if ( ! defined($offset{$tz}) );
   return ($gmtdate) if ( $tz eq $zone );

   #
   #  Convert day of week and month to numbers
   #
   local($dayofweek)   = $daynum{$day};
   local($monthofyear) = $monum{$month};
  
   $delta = $offset{$tz} - $offset{$zone}; 
   $hour  = $hour - $delta;

   # 
   #  Adjust hour, day of week, month and year if we're in previous day
   #
   if ( $hour <  0 ) { 
      $hour = $hour + 24; 
      $dayofweek--; 
      $dayofmonth--;
      if ( $dayofweek <  0 ) { 
         $dayofweek = $dayofweek +  7;
      }
      if ( $dayofmonth == 0 ) { 
         $monthofyear--; 
         $dayofmonth = $daysinmo[$monthofyear];
         if ( ($monthofyear == 1) && ($year == 96) ) { 
            $dayofmonth = 29;
         }
      }
      if ( $monthofyear < 0 ) { 
         $monthofyear = $monthofyear + 12; 
         $year--; 
      }
   }
   # 
   #  Adjust hour, day of week, month and year if we're in next day
   #
   if ( $hour > 24 ) { 
      $hour = $hour - 24; 
      $dayofweek++; 
      $dayofmonth++;
      if ( $dayofweek >  6 ) { 
         $dayofweek = $dayofweek -  7;
      }
      if ( $dayofmonth > $daysinmo[$monthofyear] ) { 
         $monthofyear++; 
         $dayofmonth = 1;
         if ( ($monthofyear == 3) && ($year == 96) ) { 
            $monthofyear = 2;
            $dayofmonth = 29;
         }
      }
      if ( $monthofyear > 11 ) { 
         $monthofyear = $monthofyear - 12; 
         $year++; 
      }
   }

   $day   = $dofw[$dayofweek];
   $month = $mofy[$monthofyear];
   $zone  = $tz;

   $returnval = sprintf("%s, %2d %s %s %02d:%02d:%02d %s",
                $day,$dayofmonth,$month,$year,$hour,$min,$sec,$zone);

print T "> $returnval\n>\n";

   return($returnval);
}

#======================================================================
1; # return true
